<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat&family=Roboto&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/style.css">
    <title>Notasi Big O</title>
</head>

<body>
    <nav class="navbar sticky-top navbar-expand-lg navbar-light bg-hijau">
        <a class="navbar-brand" href="https://github.com/fauzulIchwan">MFI</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
          <ul class="navbar-nav">
            <li class="nav-item">
              <a class="nav-link" href="index.html">Home</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="profil.html">Profil</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="tugas.html">Tugas</a>
            </li>
          </ul>
        </div>
      </nav>

    <div class="container-fluid mt-2">
        <div class="text-center">
            <h2 class="text-hijau">Notasi Big O</h2>
            <div class="row">
                <div class="col-sm-12 col-lg-6 com-md-6 mb-3">
                  <div class="card h-100 bg-hitam">
                    <div class="card-body text-light">
                      <h5 class="card-title text-hijau">Definisi</h5>
                      <p class="roboto card-text text-justify"><span class="tab-2"></span><b>Notasi O-Besar</b> adalah cara yang digunakan untuk menguraikan laju pertumbuhan suatu fungsi yang tidak lain adalah time complexity suatu algoritma. Notasi O-Besar pertama kali dikenalkan oleh pakar teori bilangan Paul Bachman pada tahun 1894 dalam bukunya Analytische Zahlentheorie ("analytic number theory") volume dua untuk menyatakan asymptotic upper bounds suatu fungsi.  Volume pertamanya diterbitkan tahun 1892 tetapi belum memuat notasi O. Notasi ini dipopulerkan pada teori bilangan oleh Edmund Landau yang kemudian kerap disebut simbol Landau. pada ilmu komputer notasi O-Besar diklaim sudah dikenal sejak tahun 1927 yang kemudian dipopulerkan kembali penggunaannya oleh Knuth (1976, 1998, 1999) yang juga mengenalkan kembali notasi Omega dan Theta. Notasi O-Besar, dibaca sebagai “order of”, aslinya menggunakan simbol omikron besar. Saat ini digunakan huruf besar Latin O yang kelihatannya mirip dengan omikron.
                        <br><span class="tab-2"></span>Secara sederhana notasi O-Besar
                        didefinisikan sebagai berikut: Jika n adalah ukuran masukan dan f(n) serta g(n) adalah fungsi positif dari n maka f(n) adalah O(g(n)) jika dan hanya jika terdapat konstanta positif c dan integer positif n0 sedemikian rupa sehingga f(n) ≤ c g(n) untuk semua n ≥ n0.</p>
                    </div>
                  </div>
                </div>
                <div class="col-sm-12 col-lg-6 com-md-6 mb-3">
                  <div class="card h-100 bg-hitam">
                    <div class="card-body text-light">
                      <h5 class="card-title text-hijau">Kegunaan</h5>
                      <p class="roboto text-justify card-text"> 
                        <span class="tab-2"></span>notasi ini kerap dipakai pada analisis algoritma untuk menguraikan algoritma pemakaian sumber-sumber komputasi: kasus terburuk atau kasus rerata waktu eksekusi atau pemakaian memori suatu algoritma kerap disajikan sebagai fungsi dari besaran masukan menggunakan notasi O-Besar. Hal ini memungkinkan perancang algoritma memprediksi perilaku algoritmanya dan menentukan algoritma mana yang akan digunakan tak tergantung pada arsitektur komputer dan clock rate. Karena notasi O-Besar mengabaikan nilai konstanta dan kelipatannya dan juga mengabaikan efisiensi untuk argumenargumen dalam ukuran yang lebih kecil ordernya, maka notasi O besar tidak selalu mencerminkan algortima yang paling cepat pada data tertentu, tetapi pendekatan ini tetap sangat efektif untuk membandingkan berbagai algoritma saat ukuran data masukan menuju tak terhingga.
                        </p>
                    </div>
                  </div>
                </div><!--col-sm-12 col-lg-6 com-md-6 mb-3-->
              </div><!--row-->
              <h2 class="text-hijau">Contoh Notasi Big O</h2>
              <div class="row">
              <div class="col-sm-12 col-lg-6 com-md-6 mb-3">
                <div class="card h-100 bg-hitam">
                <img src="img/O-1.png" class="card-img-top" alt="O(1)">
                  <div class="card-body text-light">
                    <h5 class="card-title text-hijau">O(1)-Kompleksitas waktu Konstan</h5>
                            <p class="card-text roboto text-justify"><span class="tab-1"></span>O(1) menjelaskan algoritma yang akan selalu dijalankan dalam waktu (atau ruang) yang sama terlepas dari ukuran kumpulan data masukan. Saat input bertambah, waktu untuk menjalankan algoritma tetap konstan. Biasa ditemukan pada tabel lookup konstan dan program pembeda bilangan ganjil-genap.
                    </div>
                </div>
              </div>
                    <div class="col-sm-12 col-lg-6 com-md-6 mb-3">
                        <div class="card h-100 bg-hitam">
                            <img src="img/o-n.png" class="card-img-top" alt="O(n)">
                            <div class="card-body text-light">
                                <h5 class="card-title text-hijau">O(n)-Kompleksitas waktu Linear</h5>
                                <p class="card-text roboto text-justify"><span class="tab-1"></span>O(n) menggambarkan algoritma yang kinerjanya akan tumbuh secara linier dan dalam proporsi langsung dengan ukuran kumpulan data masukan. Seiring bertambahnya masukan, waktu untuk menjalankan algoritma akan bertambah secara proporsional. dapat ditemukan dalam program untuk menemukan item dalam daftar yang tidak diurutkan atau dalam array yang tidak diurutkan.</p>
                            </div>
                        </div>
                    </div>
                    <div class="col-sm-12 col-lg-6 com-md-6 mb-3">
                        <div class="card h-100 bg-hitam">
                            <img src="img/o-n2.png" class="card-img-top" alt="O(n2)">
                            <div class="card-body text-light">
                                <h5 class="card-title text-hijau">O(n<sup>2</sup>)-Kompleksitas waktu Kuadratik</h5>
                                <p class="card-text roboto text-justify"><span class="tab-1"></span>O(n<sup>2</sup>) mewakili algoritma yang kinerjanya berbanding lurus dengan kuadrat ukuran kumpulan data masukan. Ini umum terjadi pada algoritma yang melibatkan iterasi bersarang atas kumpulan data. Seiring bertambahnya masukan, waktu untuk menjalankan algoritma bertambah dengan kecepatan kuadratnya. Biasa ditemukan pada algoritma pengurutan sederhana, seperti bubble sort, selection sort dan insertion sort</p>
                            </div>
                        </div>
                    </div>
                    <div class="col-sm-12 col-lg-6 com-md-6 mb-3">
                        <div class="card h-100 bg-hitam">
                            <img src="img/o-log-n.png" class="card-img-top" alt="EDC">
                            <div class="card-body text-light">
                                <h5 class="card-title text-hijau">O(log n)-Kompleksitas waktu Logaritmik</h5>
                                <p class="card-text roboto text-justify"><span class="tab-1"></span>O (log N) pada dasarnya berarti waktu naik secara linier sedangkan n naik secara eksponensial. Jadi, jika perlu 1 detik untuk menghitung 10 elemen, dibutuhkan 2 detik untuk menghitung 100 elemen, 3 detik untuk menghitung 1000 elemen, dan seterusnya. biasa ditemukan pada algoritma binary seach</p>
                            </div>
                        </div>
                    </div>
                </div>
        </div>
    </div>

    <div class="bg-hijau text-dark p-2">
        <h5>Muh. Fauzul Ichwan</h5>
        <h6>D121181018</h6>
  </div>
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha384-B4gt1jrGC7Jh4AgTPSdUtOBvfO8shuf57BaghqFfPlYxofvL8/KUEfYiJOMMV+rV" crossorigin="anonymous"></script>
</body>
</html>