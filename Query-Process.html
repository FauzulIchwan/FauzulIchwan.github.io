<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat&family=Roboto&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/style.css">
    <title>Query Process</title>
</head>

<body>
    <nav class="navbar sticky-top navbar-expand-lg navbar-light bg-hijau">
        <a class="navbar-brand" href="https://github.com/fauzulIchwan">MFI</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
          <ul class="navbar-nav">
            <li class="nav-item">
              <a class="nav-link" href="index.html">Home</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="profil.html">Profil</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" href="tugas.html">Tugas</a>
            </li>
          </ul>
        </div>
      </nav>

    <div class="container-fluid mt-2">
        <div class="text-center">
            <h2 class="text-hijau">Query Process</h2>
            <div class="row">
                <div class="col-sm-12 col-lg-12 col-md-6 mb-3">
                  <div class="card h-100 bg-hitam">
                    <div class="card-body text-light">
                      <h5 class="card-title text-hijau">Definisi</h5>
                      <p class="roboto card-text text-justify"><span class="tab-2"></span>Query Language merupakan bahasa khusus yang digunakan untuk melakukan perintah-perintah untuk mengakses data pada sistem basis data. Query Language atau yang lebih dikenal dengan nama SQL merupakan suatu bahasa yang digunakan untuk membuat sebuah database. Pemrosesan terhadap query didalam suatu sistem basis data dilakukan dengan menggunakan bahasa query (Query Language),bahasa query formal.basis data relasional adalah bahasa untuk meminta informasi dari basis data. sebelum adanya bahasa tersebut, query terhadap basis data merupakan tugas yang sangat sukar, karena pemrograman hasur berurusan dengan skema fisik internal dari basis data.
                        <br>
                        <br><span class="tab-2"></span> query relasional (SQL) berbeda dengan bahasa pemrograman konvensional. Di SQL, kita menspesifikasikan properti-properti informasi yang hendak diambil tapi tidak mencantumkan rincian algoritma pengambilan. SQL bersifat deklaratif, yaitu pada query dideklarasikan informasi yang merupakan jawaban yang dikehendaki bukan cara komputasi. query relasional formal merupakan bahasa antara yang digunakan basis data yaitu SQL dikonversi menjadi bahasa relasional formal sehingga dapat diterapkan sekumpulan informasi untuk memperoleh query paling efisien.</p>
                    </div>
                  </div>
                </div>
                <div class="col-sm-12 col-lg-12 col-md-12 mb-3">
                  <div class="card roboto h-100 bg-hitam">
                    <div class="card-body text-justify text-light">
                      <h5 class="card-title text-center montserrat text-hijau">Biaya Query</h5>
                      <p class="card-text"> 
                        <span class="tab-2"></span>Dalam DBMS, biaya yang terlibat dalam menjalankan kueri dapat diukur dengan mempertimbangkan jumlah sumber daya berbeda yang tercantum di bawah ini;
                        <ul class="text-left">
                            <li>Jumlah akses disk / jumlah transfer blok disk / ukuran tabel</li>
                            <li>Waktu yang dibutuhkan oleh CPU untuk mengeksekusi kueri</li>
                        </ul>
                        Waktu yang dibutuhkan oleh CPU dapat diabaikan di sebagian besar sistem jika dibandingkan dengan jumlah akses disk. Jika kita menganggap jumlah transfer blok sebagai komponen utama dalam menghitung biaya kueri, itu akan mencakup lebih banyak sub-komponen. Yaitu; <br><b class="text-hijau">Rotasi latensi</b> - waktu yang dibutuhkan untuk membawa dan memutar data yang diperlukan di bawah kepala baca-tulis disk. <br><b class="text-hijau">Waktu Pencarian</b> - waktu yang dibutuhkan untuk memposisikan head baca-tulis di atas track atau silinder yang diperlukan. <br><b class="text-hijau">I / O berurutan</b> - membaca data yang disimpan dalam blok disk yang berdekatan <br><b  class="text-hijau">Random I / O</b> - membaca data yang disimpan di blok berbeda yang tidak bersebelahan. <br><br><span class="tab-2"></span>Artinya, block mungkin disimpan di track yang berbeda, atau silinder yang berbeda, dll. Apakah read/write? - read membutuhkan lebih sedikit waktu, write membutuhkan lebih banyak. Dari sub-komponen ini, kita buat daftar komponen ukuran yang lebih akurat sebagai berikut; <ul>
                            <li>Jumlah operasi pencarian yang dilakukan</li> 
                            <li>Jumlah blok yang dibaca</li> 
                            <li>Jumlah blok yang ditulis Untuk mendapatkan hasil akhir</li>
                        </ul>        
                        angka-angka tersebut harus dikalikan dengan rata-rata waktu yang dibutuhkan untuk menyelesaikan tugas. Oleh karena itu, dapat dituliskan sebagai berikut; <br><br>Biaya kueri = (jumlah operasi pencarian X rata-rata waktu pencarian) + (jumlah blok membaca X rata-rata waktu transfer untuk membaca satu blok) + (jumlah blok tertulis X rata-rata waktu transfer untuk menulis blok)
                        </p>
                    </div>
                  </div>
                </div><!--col-sm-12 col-lg-6 com-md-6 mb-3-->
                <div class="col-sm-12 col-lg-12 col-md-12 mb-3">
                    <div class="card roboto h-100 bg-hitam">
                      <div class="card-body text-justify text-light">
                        <h5 class="card-title text-center montserrat text-hijau">Evaluasi Ekspresi pada DBMS</h5>
                        <p class="card-text"> 
                          <span class="tab-2"></span>Untuk mengevaluasi ekspresi yang membawa banyak operasi di dalamnya, kita dapat melakukan perhitungan setiap operasi satu per satu. Namun, dalam sistem pemrosesan kueri, kami menggunakan dua metode untuk mengevaluasi ekspresi yang membawa banyak operasi. Metode tersebut adalah:
                          <ul>
                              <li>Materialization
                                  <p>Dalam metode ini, ekspresi yang diberikan mengevaluasi satu operasi relasional dalam satu waktu. Selain itu, setiap operasi dievaluasi dalam urutan atau urutan yang sesuai. Setelah mengevaluasi semua operasi, keluarannya diwujudkan dalam hubungan sementara untuk penggunaan selanjutnya. Ini membawa metode materialisasi pada kerugian. Kerugiannya adalah bahwa ia perlu membangun hubungan sementara tersebut untuk mewujudkan hasil operasi yang dievaluasi, masing-masing. Hubungan sementara ini ditulis pada disk kecuali ukurannya kecil.</p>
                              </li>
                              <li>Pipelining
                                  <p>Pipelining adalah metode alternatif atau pendekatan untuk metode materialisasi. Dalam pipelining, ini memungkinkan kita untuk mengevaluasi setiap operasi relasional ekspresi secara bersamaan dalam pipeline. Dalam pendekatan ini, setelah mengevaluasi satu operasi, keluarannya diteruskan ke operasi berikutnya, dan rantai berlanjut hingga semua operasi relasional dievaluasi secara menyeluruh. Jadi, tidak ada persyaratan untuk menyimpan hubungan sementara dalam pemipaan. Keuntungan dari pipelining membuatnya menjadi pendekatan yang lebih baik dibandingkan dengan pendekatan yang digunakan dalam metode materialisasi. Bahkan biaya dari kedua pendekatan dapat memiliki perbedaan di antara keduanya. Namun, kedua pendekatan tersebut menjalankan peran terbaik dalam kasus yang berbeda. Dengan demikian, kedua cara tersebut layak di tempatnya.</p>
                              </li>
                          </ul>
                          </p>
                      </div>
                    </div>
                  </div><!--col-sm-12 col-lg-6 com-md-6 mb-3-->
              </div><!--row-->
        </div>
    </div>

    <div class="bg-hijau text-dark p-2">
        <h5>Muh. Fauzul Ichwan</h5>
        <h6>D121181018</h6>
  </div>
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha384-B4gt1jrGC7Jh4AgTPSdUtOBvfO8shuf57BaghqFfPlYxofvL8/KUEfYiJOMMV+rV" crossorigin="anonymous"></script>
</body>
</html>